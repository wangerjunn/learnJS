//数据类型和变量

JavaScript不区分整数和浮点数，统一用Number表示

NaN 表示Not a Number,当无法计算结果时用NaN表示
Infinity 表示无限大，当数值超过了JavaScript的Number所能表示的最大值，就表示为Infinity

==表示相等运算符，它会自动转换数据类型再比较
===比较它不会自动转换数据类型，如果数据类型不一致，返回false，使用===比较

NaN这个特殊的Number与所有其他值都不相等，包括自己：NaN === NaN；//false

唯一能判断NaN的方法通过isNaN();

浮点数相等比较：
	浮点数在运算过程中会产生误差，比较浮点数是否相等，只能计算他们之差的绝对值，看是否小于某个阈值

null和undefined
	null表示一个空值，它和0以及空字符串''不同，0是一个数值，''表示长度为哦的字符串，null表示空
JavaScript把null、undefined、0、nan和空字符串‘’视为FALSE，其他值视为true

数组：是一组按顺序排列的集合，数组可以包括任意数据类型。[1,2,'HELLO'，false]；
	slice()就是对应String的substring()版本，它截取Array的部分元素，然后返回一个新的Array：
	如果不给slice()传递任何参数，它就会从头到尾截取所有元素
	var arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];
	arr.slice(0, 3); // 从索引0开始，到索引3结束，但不包括索引3: ['A', 'B', 'C']
	arr.slice(3); // 从索引3开始到结束: ['D', 'E', 'F', 'G']

	push()向Array的末尾添加若干元素，pop()则把Array的最后一个元素删除掉：
	unshift和shift
	如果要往Array的头部添加若干元素，使用unshift()方法，shift()方法则把Array的第一个元素删掉：
	var arr = [1, 2];
	arr.unshift('A', 'B'); // 返回Array新的长度: 4
	arr; // ['A', 'B', 1, 2]
	arr.shift(); // 'A'
	arr; // ['B', 1, 2]
	arr.shift(); arr.shift(); arr.shift(); // 连续shift 3次
	arr; // []
	arr.shift(); // 空数组继续shift不会报错，而是返回undefined
	arr; // []

	reverse()把整个Array的元素给倒序，也就是反转
	splice()方法是修改Array的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素
	var arr = ['Microsoft', 'Apple', 'Yahoo', 'AOL', 'Excite', 'Oracle'];
	// 从索引2开始删除3个元素,然后再添加两个元素:
	arr.splice(2, 3, 'Google', 'Facebook'); // 返回删除的元素 ['Yahoo', 'AOL', 'Excite']
	arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']
	// 只删除,不添加:
	arr.splice(2, 2); // ['Google', 'Facebook']
	arr; // ['Microsoft', 'Apple', 'Oracle']
	// 只添加,不删除:
	arr.splice(2, 0, 'Google', 'Facebook'); // 返回[],因为没有删除任何元素
	arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']
	
对象：是一组由键-值组成的无序集合，例如:
var person = {
	name:'Bob',
	age:20
}
	获取对象属性，可用 对象变量.属性名:person.name
	由于JavaScript的对象是动态类型，可以自由的对对象添加/删除
	//删除  delete person.age
	//添加 person.height = 180;

	检测是否拥有某一个属性，可以用in操作符： 'name' in person;//true
	判断一个属性是否是自身拥有的，可用 hasOwnProperty()方法：
		eg: person.hasOwnProperty('name');//true

变量
	变量在JavaScript中就是用一个变量名表示，变量名是大小写英文、数字、$和_的组合，且不能用数字开头。变量名也不能是JavaScript的关键字，如if、while等。申明一个变量用var语句

strict模式
	JavaScript在设计之初，为了方便初学者学习，并不强制要求用var申明变量。这个设计错误带来了严重的后果：如果一个变量没有通过var申明就被使用，那么该变量就自动被申明为全局变量：

	i = 10; // i现在是全局变量

字符串：用''或""括起来的字符表示。如果'本身也是一个字符，那就可以用""括起来
	如果有很多变量需要连接，用+号就比较麻烦。ES6新增了一种模板字符串，表示方法和上面的多行字符串一样，但是它会自动替换字符串中的变量：
	var name = '小明';
	var age = 20;
	var message = `你好, ${name}, 你今年${age}岁了!`;
	alert(message);

循环：for循环的3个条件都是可以省略的，如果没有退出循环的判断条件，就必须使用break语句退出循环，否则就是死循环。
	eg:
		var x = 0;
		for(;;) { //将无限循环下去
			if(x > 100) {
				break;
			}
		}


	 for ... in ,它可以把一个对象的所有属性一次循环出来：
	 	eg: 
	 		var o = {
	 			name :'jack';
	 			age :13;
	 			city:'beijing'
	 		}

	 		for (var a in o) {
	 			alert(a);
	 		}

	array、map、set都属于iterable类型。具有iterable类型的集合可以通过for ... of循环便利,for ... of 是ES6引入的新语法
	
		var a = [1,23,4];
		for (var x of a) {

		}
    
	然后，更好的方式是直接使用iterable内置的foreach方法，每次迭代就自动调用该函数
	ES6引入

    eg :
    	var a = ['a','b','c'];

    	a.forEach(function(element,index,array)) {
    		//element指向当前元素的值
    		//index 当前索引下标
    		//array 指向array对象本身
    	};


    	//Set
    	var a = new Set(['a','n','d']);

    	a.forEach(function (element,sameElement,set)){

    	};

    	//map

    	var map = new Map([[1,'x'],[2,'y'],[3,'y']]);

    	map.forEach(function (value,key,map)){

    	};


函数
	
	1.函数定义和调用
		在JavaScript中，定义函数格式如下：
			function abs(x) {

				if(argument.length == 0) {
					return 0;
				}
				if x >= 0
					return x;


			}

	匿名函数 function (x) { ... },无函数名

	调用函数
	abs(10);

	传入的参数比定义的少也没有问题，eg:abs();//返回NaN
	JavaScript还有一个免费赠送的关键字argument，它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数

	rest参数 
		ES6引入了rest参数,函数允许接收任意个参数
		function  foo(a,b,...rest) {
			console.log('a = ' +a);
		}

		//调用函数
		foo(1,2,3,4,5);
		//a=1，b=2,rest = [3,4,5];

	变量作用域
		如果内部函数和外部函数的变量重名，说明函数在查找变量时从自身函数定义开始，从'内'向'外'查找。如果内部函数定义了与外部函数重名的变量，则内部函数的变量将'屏蔽'外部函数的变量。

	全局作用域
		不在任何函数内定义的变量就具有全局作用域。JavaScript默认有一个全局对象Window，全局作用域的变量实际上被绑定到window的一个属性

		‘use strict';
		var course = "learn JavaScript";
		alert(course);
		alert(window.course);

 		函数定义有两种方式，已变量方式var foo = function () {} 定义的函数实际上也是一个全局变量，因此顶层函数的定义也被视为一个全局变量，并绑定到window对象：

 		'use strict';
 		function foo () {
 			alert('foo');
 		}

 		foo();//直接调用foo();
 		window.foo();

 	名字空间；减少冲突的一个方法是把自己的所有变量和函数全部绑定到一个全局变量中。
  
  		//唯一的全局变量MYAPP;

  		var MYAPP = {};

  		//其他变量：
  		MYAPP.name = 'myapp';
  		MYAPP。version = 1.0;

  		//其它函数：
  		MYAPP.foo = function () {
  			return 'foo';
  		};


  	局部作用域
  		由于JavaScript的变量作用域实际上是函数内部，我们在for循环等语句中是无法定义具有局部作用域的变量的:
  			'use strict';

  			function foo () {
  				for (var i = 0;i < 100; i++) {
  					//
  				}

  				i+=100;//仍然可以因拥抱变量I
  			}


  		为了解决块级作用域，ES6引入了新的关键字let，用let替代var可以申明一个块级作用域的变量：
  			'use strict';
  			fucntion foo {
  				var sum = 0;

  				for(let i = 0 ; i < 100; i++) {
  					sum += i;
  				}

  				i += 1; //syntaxError;
  			}


  	方法

  		'use strict';

  		var xiaoming = {
  			name: '小名',
  			birth : 1990,
  			age: function () {
  				var that = this;
  				function  getAgeFromBirth() {

  					let y = new Date().getFullYear;
  					return y - that.birth;
  				}
  			}
  		}

  		xiaoming.age();





















































